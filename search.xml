<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 8 新特性之 Stream 流基础体验</title>
    <url>/posts/bf1cd5c4/</url>
    <content><![CDATA[<p><img src="/uploads/img/stream-api.png" alt="stream-api"></p>
<blockquote>
<p>Java8新增的功能中,要数lambda表达式和流API最为重要了.这篇文章主要介绍流API的基础,也是流API系列的第一篇文章,话不多说,直奔主题.</p>
</blockquote>
<span id="more"></span>

<h3 id="一、什么是流API-它能做一些什么"><a href="#一、什么是流API-它能做一些什么" class="headerlink" title="一、什么是流API? 它能做一些什么?"></a>一、什么是流API? 它能做一些什么?</h3><p>我们应该知道(绝对知道~)API是一个程序向使用者提供的一些方法,通过这些方法就能实现某些功能.所以对于流API来说,重点是怎么理解”流”这个概念,所谓的流:就是数据的渠道,所以,流代表的是一个对象的序列.它和Java I/O类里使用的”流”不同.虽然在概念上与java.util.stream中定义的流是类似的,但它们是不同的.流API中的流是描述某个流类型的对象.</p>
<p>流API中的流操作的数据源,是数组或者是集合.它本身是不存储数据的,只是移动数据,在移动过程中可能会对数据进行过滤,排序或者其它操作.但是,一般情况下(绝大数情况下),流操作本身不会修改数据源.比如,对流排序不会修改数据源的顺序.相反,它会创建一个新的流,其中包含排序后的结果.</p>
<h3 id="二、从一个简单的例子，体验流API的强大与优雅"><a href="#二、从一个简单的例子，体验流API的强大与优雅" class="headerlink" title="二、从一个简单的例子，体验流API的强大与优雅"></a>二、从一个简单的例子，体验流API的强大与优雅</h3><p>这个简单的Demo,主要是对一个由1-6乱序组成的List对应的流进行操作,然后通过这个流,就可以获取到列表里面最大最小值,排序,过滤某些元素等等的操作.并且这此操作不会改变原List里面的数据.Demo里面需要注意的地方就是流API里面的”终端操作”和”中间操作”的区别:其实也很简单,终端操作会消费流,一个被消费过的流是不能被再次利用的,但我们在实际应用的时候,并不会受到太大的影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">learnStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先,创建一个1-6乱序的List</span></span><br><span class="line">        List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        lists.add(<span class="number">4</span>);</span><br><span class="line">        lists.add(<span class="number">3</span>);</span><br><span class="line">        lists.add(<span class="number">6</span>);</span><br><span class="line">        lists.add(<span class="number">1</span>);</span><br><span class="line">        lists.add(<span class="number">5</span>);</span><br><span class="line">        lists.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看看List里面的数据是什么样子的先</span></span><br><span class="line">        System.out.print(<span class="string">&quot;List里面的数据:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Integer elem : lists) &#123;</span><br><span class="line">            <span class="comment">// 4 3 6 1 5 2</span></span><br><span class="line">            System.out.print(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最小值</span></span><br><span class="line">        System.out.print(<span class="string">&quot;List中最小的值为:&quot;</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = lists.stream();</span><br><span class="line">        Optional&lt;Integer&gt; min = stream.min(Integer::compareTo);</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        min.ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大值</span></span><br><span class="line">        System.out.print(<span class="string">&quot;List中最大的值为:&quot;</span>);</span><br><span class="line">        <span class="comment">// 6</span></span><br><span class="line">        lists.stream().max(Integer::compareTo).ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        System.out.print(<span class="string">&quot;将List流进行排序:&quot;</span>);</span><br><span class="line">        Stream&lt;Integer&gt; sorted = lists.stream().sorted();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">        sorted.forEach(elem -&gt;System.out.print(elem +<span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤</span></span><br><span class="line">        System.out.print(<span class="string">&quot;过滤List流,只剩下那些大于3的元素:&quot;</span>);</span><br><span class="line">        <span class="comment">// 4 5 6</span></span><br><span class="line">        lists.stream().filter(elem -&gt; elem &gt;<span class="number">3</span>).forEach(elem -&gt;System.out.print(elem +<span class="string">&quot; &quot;</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤List流,只剩下那些大于0并且小于4的元素:\n=====begin=====&quot;</span>);</span><br><span class="line">        <span class="comment">// 1 2 3</span></span><br><span class="line">        lists.stream().filter(elem -&gt; elem &gt;<span class="number">0</span>).filter(elem -&gt; elem &lt;<span class="number">4</span>).sorted(Integer::compareTo).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====end=====&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 经过了前面的这么多流操作,我们再来看看List里面的值有没有发生什么改变</span></span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;原List里面的数据:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Integer elem : lists) &#123;</span><br><span class="line">            <span class="comment">// 4 3 6 1 5 2</span></span><br><span class="line">            System.out.print(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        learnStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我详细介绍一下整个Demo,让大家更加清淅:</p>
<h4 id="1-最小值"><a href="#1-最小值" class="headerlink" title="1. 最小值"></a>1. 最小值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小值</span></span><br><span class="line">      System.out.print(<span class="string">&quot;List中最小的值为:&quot;</span>);</span><br><span class="line">      Stream&lt;Integer&gt; stream = lists.stream();</span><br><span class="line">      Optional&lt;Integer&gt; min = stream.min(Integer::compareTo);</span><br><span class="line">      <span class="comment">// 1</span></span><br><span class="line">      min.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<p>首先通过stream()方法获取List对应的流,如果你对Java8的集合框架有一定的了解,你应该知道stream()是由Collection接口提供的.然后就可以通过min()获取流中的最小值了,当然这个流中的最小值肯定也是List里面的最小值.</p>
<p>min()方法接收一个Comparator类型的参数,这个比较器是用于比较流中的两个元素的.我们这里把Integer的compareTo()的引用传递给了min().它返回的类型是Optional,Optional可谓是NullPointException的大杀器啊,感兴趣的同学,了解一下.然后判断最小值存不存在,如果存在,就通过Optional的get()读取出来.很简单有木有!</p>
<h4 id="2-最大值"><a href="#2-最大值" class="headerlink" title="2. 最大值"></a>2. 最大值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大值</span></span><br><span class="line">      System.out.print(<span class="string">&quot;List中最大的值为:&quot;</span>);</span><br><span class="line">      <span class="comment">// 6</span></span><br><span class="line">      lists.stream().max(Integer::compareTo).ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<p>语法糖爽YY有木有,不过需要注意的一点,因为min()是一个终端操作,所以这个流是不可以再用了,因此我们需要通过stream()重新生成一个流,(但这其实并不影响我们的实际生产的:①方法功能单一原则②还有其它很多很强大的方法组合能让你实现各种功能啊.)ifPresent其实和上面的最小值的if判断是一定要,如果存在最大值,我们就打印一下,这里只不过用了一些函数式写法而已.</p>
<h4 id="3-排序和遍历"><a href="#3-排序和遍历" class="headerlink" title="3. 排序和遍历"></a>3. 排序和遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line">      System.out.print(<span class="string">&quot;将List流进行排序:&quot;</span>);</span><br><span class="line">      Stream&lt;Integer&gt; sorted = lists.stream().sorted();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">      sorted.forEach(elem -&gt;System.out.print(elem +<span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure>
<p>通过上面的讲解,相信这个已经难不了你了,sorted()方法是用于排序的,它的一个重载方法可以接收一个Comparator类型的参数,让你自定义你的排序规则.forEach方法就遍历.</p>
<h4 id="4-过滤"><a href="#4-过滤" class="headerlink" title="4.过滤"></a>4.过滤</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤</span></span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;过滤List流,只剩下那些大于0并且小于4的元素:\n=====begin=====&quot;</span>);</span><br><span class="line">      <span class="comment">// 1 2 3</span></span><br><span class="line">      lists.stream().filter(elem -&gt; elem &gt;<span class="number">0</span>).filter(elem -&gt; elem &lt;<span class="number">4</span>).sorted(Integer::compareTo).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;=====end=====&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>filter()是基于一个谓词过滤流,它返回一个只包含满足谓词的元素的新流.它的参数形式是Predicate,是在java.util.function包下的泛型函数式接口.并且filter是一个中间操作,而且还可以同时存在多个filter.这里的两个过滤器,我们都传递了lambda表达式.</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>其实基本的流API使用就是这么简单,结合lambda表达式后,一切都变得特别清淅.这个简单的Demo展示了一些基础的功能,它或许就扩展了你操作数组或者集合框架的思路,让你操作集合和数组,变得更加的容易,简单和高效.</p>
<h3 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h3><p>原文链接：<a href="https://mp.weixin.qq.com/s/h1kUcyOIillMP4Qn4QO-Ig">跟我学 Java 8 新特性之 Stream 流基础体验</a></p>
]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代码模拟高并发操作</title>
    <url>/posts/2a28db14/</url>
    <content><![CDATA[<blockquote>
<p>Java通过代码模拟高并发可以以最快的方式发现我们系统中潜在的线程安全性问题，此处使用<code>Semaphore</code>（信号量）和 <code>CountDownLatch</code>（闭锁）搭配<code>ExecutorService</code>（线程池）来进行模拟</p>
</blockquote>
<span id="more"></span>

<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>JDK 1.5之后会提供这个类，Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。其原理图如下：<br><img src="/uploads/img/semaphore.png" alt="Semaphore原理图"></p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>JDK 1.5之后会提供这个类，CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。<br>其原理图如下：<br><img src="/uploads/img/CountDownLatch.jpg" alt="CountDownLatch原理图"></p>
<p>以上两个类可以搭配使用，达到模拟高并发的效果，以下使用代码的形式进行举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用&#123;<span class="doctag">@link</span> Semaphore&#125;和&#123;<span class="doctag">@link</span> CountDownLatch&#125;模拟并发请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hexsmith</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Semaphore</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CountDownLatch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ExecutorService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/6 22:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCountExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_TOTAL = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发执行的线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_TOTAL = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于是多线程并行操作count，因此要使用原子操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 信号量，用户控制并发线程数</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(THREAD_TOTAL);</span><br><span class="line">        <span class="comment">// 闭锁，实现计数器递减</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(CLIENT_TOTAL);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;CLIENT_TOTAL;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取执行许可，当许可不超过200时，允许通过，否则线程阻塞等待，直到获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    <span class="comment">// 释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 闭锁减一</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// main线程阻塞等待，知道闭锁值为0才继续向下执行</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数统计</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java高并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL性能优化建议</title>
    <url>/posts/265d3917/</url>
    <content><![CDATA[<h1 id="MySQL性能优化建议"><a href="#MySQL性能优化建议" class="headerlink" title="MySQL性能优化建议"></a>MySQL性能优化建议</h1><p>下面会从3个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给大家：<strong>纸上得来终觉浅，绝知此事要躬行。不要听信你看到的关于优化的“绝对真理”，</strong>包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设。</p>
<span id="more"></span>

<h3 id="Scheme设计与数据类型优化"><a href="#Scheme设计与数据类型优化" class="headerlink" title="Scheme设计与数据类型优化"></a>Scheme设计与数据类型优化</h3><p>选择数据类型只要遵循<strong>小而简单</strong>的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。越简单的数据类型在计算时需要更少的CPU周期，比如，整型就比字符操作代价低，因而会使用整型来存储ip地址，使用DATETIME来存储时间，而不是使用字符串。</p>
<p>这里总结几个可能容易理解错误的技巧：</p>
<ol>
<li>通常来说把可为<code>NULL</code>的列改为<code>NOT NULL</code>不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为<code>NOT NULL</code>。</li>
<li>对整数类型指定宽度，比如<code>INT(11)</code>，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以<code>INT(1)</code>和<code>INT(20)</code>对于存储和计算是相同的。</li>
<li><code>UNSIGNED</code>表示不允许负值，大致可以使正数的上限提高一倍。比如<code>TINYINT</code>存储范围是-128 ~ 127（这个可能经常有人掉坑里了，包括我自己 ），而<code>UNSIGNED TINYINT</code>存储的范围却是0 - 255。</li>
<li><code>TIMESTAMP</code>使用4个字节存储空间，<code>DATETIME</code>使用8个字节存储空间。因而，<code>TIMESTAMP</code>只能表示1970 - 2038年，比<code>DATETIME</code>表示的范围小得多，而且<code>TIMESTAMP</code>的值因时区不同而不同。</li>
<li>大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用<code>ALTER TABLE</code>（如果只只是在列表末尾追加元素，不需要重建表）。</li>
</ol>
<h3 id="创建高性能索引"><a href="#创建高性能索引" class="headerlink" title="创建高性能索引"></a>创建高性能索引</h3><p>索引是提高MySQL查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的SQL才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p>
<p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p>
<h4 id="索引相关的数据结构和算法"><a href="#索引相关的数据结构和算法" class="headerlink" title="索引相关的数据结构和算法"></a>索引相关的数据结构和算法</h4><p>通常我们所说的索引是指B-Tree索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用B-Tree这个术语，是因为MySQL在CREATE TABLE或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如InnoDB就是使用的B+Tree。</p>
<p>B+Tree中的B是指balance，意为平衡。需要注意的是，<strong>B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据</strong>。</p>
<p>在介绍B+Tree前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图①。如果要在这课树中查找值为5的记录，其大致流程：先找到根，其值为6，大于5，所以查找左子树，找到3，而5大于3，接着找3的右子树，总共找了3次。同样的方法，如果查找值为8的记录，也需要查找3次。所以二叉查找树的平均查找次数为(3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3次，而顺序查找的话，查找值为2的记录，仅需要1次，但查找值为8的记录则需要6次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3次，因此大多数情况下二叉查找树的平均查找速度比顺序查找要快。</p>
<p><img src="/images/2020/09/22/2f00aa24-a7e2-4b41-98df-b7e399ac907b.jpg" alt="二叉树与平衡二叉树.jpg"></p>
<p>​                                                                    二叉查找树和平衡二叉树</p>
<p>由于二叉查找树可以任意构造，同样的值，可以构造出如图②的二叉查找树，显然这棵二叉树的查询效率和顺序查找差不多。若想二叉查找数的查询性能最高，需要这棵二叉查找树是平衡的，也即平衡二叉树（AVL树）。</p>
<p>平衡二叉树首先需要符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度差不能大于1。显然图②不满足平衡二叉树的定义，而图①是一课平衡二叉树。平衡二叉树的查找性能是比较高的（性能最好的是最优二叉树），查询性能越好，维护的成本就越大。比如图①的平衡二叉树，当用户需要插入一个新的值9的节点时，就需要做出如下变动。</p>
<p><img src="/images/2020/09/22/09ad2c34-ec21-4451-8438-6d1ebd63522b.jpg" alt="平衡二叉树旋转.jpg"></p>
<p>​                                                                                平衡二叉树旋转</p>
<p>通过一次左旋操作就将插入后的树重新变为平衡二叉树是最简单的情况了，实际应用场景中可能需要旋转多次。至此我们可以考虑一个问题，平衡二叉树的查找效率还不错，实现也非常简单，相应的维护成本还能接受，为什么MySQL索引不直接使用平衡二叉树？</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的I/O读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的I/O存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将二叉树变为m叉树（多路搜索树），而B+Tree就是一种多路搜索树。理解B+Tree时，只需要理解其最重要的两个特征即可：第一，所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page），非叶子节点（Index Page）并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。其次，所有的叶子节点由指针连接。如下图为高度为2的简化了的B+Tree。</p>
<p><img src="/images/2020/09/22/197e9d4d-a618-40d1-86d8-fae4e2b3dd32.jpg" alt="简化BTree.jpg"></p>
<p>​                                                                                    简化B+Tree</p>
<p>怎么理解这两个特征？MySQL将每个节点的大小设置为一个页的整数倍（原因下文会介绍），也就是在节点空间大小一定的情况下，每个节点可以存储更多的内结点，这样每个结点能索引的范围更大更精确。所有的叶子节点使用指针链接的好处是可以进行区间访问，比如上图中，如果查找大于20而小于30的记录，只需要找到节点20，就可以遍历指针依次找到25、30。如果没有链接指针的话，就无法进行区间查找。这也是MySQL使用B+Tree作为索引存储结构的重要原因。</p>
<p>MySQL为何将节点大小设置为页的整数倍，这就需要理解磁盘的存储原理。磁盘本身存取就比主存慢很多，在加上机械运动损耗（特别是普通的机械硬盘），磁盘的存取速度往往是主存的几百万分之一，为了尽量减少磁盘I/O，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，预读的长度一般为页的整数倍。</p>
<p>页是计算机管理存储器的逻辑块，硬件及OS往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（许多OS中，页的大小通常为4K）。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后一起返回，程序继续运行。</p>
<p>MySQL巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了读取一个节点只需一次I/O。假设B+Tree的高度为h，一次检索最多需要h-1I/O（根节点常驻内存），复杂度$O(h) = O(\log_{M}N)$。实际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。</p>
<p>最后简单了解下B+Tree节点的操作，在整体上对索引的维护有一个大概的了解，虽然索引可以大大提高查询效率，但维护索引仍要花费很大的代价，因此合理的创建索引也就尤为重要。</p>
<p>仍以上面的树为例，我们假设每个节点只能存储4个内节点。首先要插入第一个节点28，如下图所示。</p>
<p><img src="/images/2020/09/22/0feed6b3-b030-4620-8ec7-114493b241b2.jpg" alt="leaf page和index page都没有满.jpg"></p>
<p>​                                                            leaf page和index page都没有满</p>
<p>接着插入下一个节点70，在Index Page中查询后得知应该插入到50 - 70之间的叶子节点，但叶子节点已满，这时候就需要进行也分裂的操作，当前的叶子节点起点为50，所以根据中间值来拆分叶子节点，如下图所示。</p>
<p><img src="/images/2020/09/22/57b33d6b-f246-4fd6-8a92-cb9a86a2ab1b.jpg" alt="Leaf Page拆分.jpg"></p>
<p>​                                                                            Leaf Page拆分</p>
<p>最后插入一个节点95，这时候Index Page和Leaf Page都满了，就需要做两次拆分，如下图所示。</p>
<p><img src="/images/2020/09/22/9274ef88-1c4e-4518-aa24-c5d4c2296bed.jpg" alt="Leaf Page与Index Page拆分.jpg"></p>
<p>​                                                                Leaf Page与Index Page拆分</p>
<p>拆分后最终形成了这样一颗树。</p>
<p><img src="/images/2020/09/22/832e2cdb-cf4c-43b7-b09a-ef57c1ec04e0.jpg" alt="最终树.jpg"></p>
<p>​                                                                                        最终树</p>
<p>B+Tree为了保持平衡，对于新插入的值需要做大量的拆分页操作，而页的拆分需要I/O操作，为了尽可能的减少页的拆分操作，B+Tree也提供了类似于平衡二叉树的旋转功能。当Leaf Page已满但其左右兄弟节点没有满的情况下，B+Tree并不急于去做拆分操作，而是将记录移到当前所在页的兄弟节点上。通常情况下，左兄弟会被先检查用来做旋转操作。就比如上面第二个示例，当插入70的时候，并不会去做页拆分，而是左旋操作。</p>
<p><img src="/images/2020/09/22/1ec74477-78ac-47f3-b10d-b49985fa9511.jpg" alt="左旋操作.jpg"></p>
<p>​                                                                                    左旋操作</p>
<p>通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的I/O操作，也提高索引维护效率。需要注意的是，删除节点跟插入节点类似，仍然需要旋转和拆分操作，这里就不再说明。</p>
<h4 id="高性能策略"><a href="#高性能策略" class="headerlink" title="高性能策略"></a>高性能策略</h4><p>通过上文，相信你对B+Tree的数据结构已经有了大致的了解，但MySQL中索引是如何组织数据的存储呢？以一个简单的示例来说明，假如有如下数据表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE People(</span><br><span class="line"></span><br><span class="line">  last_name varchar(50) not null,</span><br><span class="line"></span><br><span class="line">  first_name varchar(50) not null,</span><br><span class="line"></span><br><span class="line">  dob date not null,</span><br><span class="line"></span><br><span class="line">  gender enum(`m`,`f`) not null,</span><br><span class="line"></span><br><span class="line">  key(last_name,first_name,dob)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>





<p>对于表中每一行数据，索引中包含了last_name、first_name、dob列的值，下图展示了索引是如何组织数据存储的。</p>
<p><img src="/images/2020/09/22/5ef0d3b9-a212-406c-a728-7e6f49dc883d.jpg" alt="索引如何组织数据存储.jpg"></p>
<p>​                                                        索引如何组织数据存储，来自：高性能MySQL</p>
<p>可以看到，索引首先根据第一个字段来排列顺序，当名字相同时，则根据第三个字段，即出生日期来排序，正是因为这个原因，才有了索引的“最左原则”。</p>
<p><strong>1、MySQL不会使用索引的情况：非独立的列</strong></p>
<p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from where id + 1 = 5</span><br></pre></td></tr></table></figure>



<p>我们很容易看出其等价于 id = 4，但是MySQL无法自动解析这个表达式，使用函数是同样的道理。</p>
<p><strong>2、前缀索引</strong></p>
<p>如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率。</p>
<p><strong>3、多列索引和索引顺序</strong></p>
<p>在多数情况下，在多个列上建立独立的索引并不能提高查询性能。理由非常简单，MySQL不知道选择哪个索引的查询效率更好，所以在老版本，比如MySQL5.0之前就会随便选择一个列的索引，而新的版本会采用合并索引的策略。举个简单的例子，在一张电影演员表中，在actor_id和film_id两个列上都建立了独立的索引，然后有如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select film_id,actor_id from film_actor where actor_id = 1 or film_id = 1</span><br></pre></td></tr></table></figure>

<p>老版本的MySQL会随机选择一个索引，但新版本做如下的优化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select film_id,actor_id from film_actor where actor_id = 1 </span><br><span class="line"></span><br><span class="line">union all</span><br><span class="line"></span><br><span class="line">select film_id,actor_id from film_actor where film_id = 1 and actor_id &lt;&gt; 1</span><br></pre></td></tr></table></figure>





<ul>
<li>当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引。</li>
<li>当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。</li>
</ul>
<p>因此explain时如果发现有索引合并（Extra字段出现Using union），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。</p>
<p>前面我们提到过索引如何组织数据存储的，从图中可以看到多列索引时，索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</p>
<p>索引选择性是指不重复的索引值和数据表的总记录数的比值，选择性越高查询效率越高，因为选择性越高的索引可以让MySQL在查询时过滤掉更多的行。唯一索引的选择性是1，这时最好的索引选择性，性能也是最好的。</p>
<p>理解索引选择性的概念后，就不难确定哪个字段的选择性较高了，查一下就知道了，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM payment where staff_id = 2 and customer_id = 584</span><br></pre></td></tr></table></figure>



<p>是应该创建(staff_id,customer_id)的索引还是应该颠倒一下顺序？执行下面的查询，哪个字段的选择性更接近1就把哪个字段索引前面就好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct staff_id)/count(*) as staff_id_selectivity,</span><br><span class="line"></span><br><span class="line">  count(distinct customer_id)/count(*) as customer_id_selectivity,</span><br><span class="line"></span><br><span class="line">  count(*) from payment</span><br></pre></td></tr></table></figure>



<p>多数情况下使用这个原则没有任何问题，但仍然注意你的数据中是否存在一些特殊情况。举个简单的例子，比如要查询某个用户组下有过交易的用户信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user_id from trade where user_group_id = 1 and trade_amount &gt; 0</span><br></pre></td></tr></table></figure>

<p>MySQL为这个查询选择了索引(user_group_id,trade_amount)，如果不考虑特殊情况，这看起来没有任何问题，但实际情况是这张表的大多数数据都是从老系统中迁移过来的，由于新老系统的数据不兼容，所以就给老系统迁移过来的数据赋予了一个默认的用户组。这种情况下，通过索引扫描的行数跟全表扫描基本没什么区别，索引也就起不到任何作用。</p>
<p>推广开来说，经验法则和推论在多数情况下是有用的，可以指导我们开发和设计，但实际情况往往会更复杂，实际业务场景下的某些特殊情况可能会摧毁你的整个设计。</p>
<p><strong>4、避免多个范围条件</strong></p>
<p>实际开发中，我们会经常使用多个范围条件，比如想查询某个时间段内登录过的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user.* from user where login_time &gt; &#x27;2017-04-01&#x27; and age between 18 and 30;</span><br></pre></td></tr></table></figure>





<p>这个查询有一个问题：它有两个范围条件，login_time列和age列，MySQL可以使用login_time列的索引或者age列的索引，但无法同时使用它们。</p>
<p><strong>5、覆盖索引</strong></p>
<p>**<br>**</p>
<p>如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：</p>
<ul>
<li>索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量</li>
<li>索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多</li>
</ul>
<p><strong>6、使用索引扫描来排序</strong></p>
<p>**<br>**</p>
<p>MySQL有两种方式可以生产有序的结果集，其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。如果explain的结果中type列的值为index表示使用了索引扫描来做排序。</p>
<p>扫描索引本身很快，因为只需要从一条索引记录移动到相邻的下一条记录。但如果索引本身不能覆盖所有需要查询的列，那么就不得不每扫描一条索引记录就回表查询一次对应的行。这个读取操作基本上是随机I/O，因此按照索引顺序读取数据的速度通常要比顺序地全表扫描要慢。</p>
<p>在设计索引时，如果一个索引既能够满足排序，又满足查询，是最好的。</p>
<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向也一样时，才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY子句和查询的限制是一样的，都要满足最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其它情况下都需要执行排序操作，而无法利用索引排序。</p>
<p>// 最左列为常数，索引：(date,staff_id,customer_id)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select staff_id,customer_id from demo where date = &#x27;2015-06-01&#x27; order by staff_id,customer_id</span><br></pre></td></tr></table></figure>





<p><strong>7、冗余和重复索引</strong></p>
<p>冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。</p>
<p>大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。</p>
<p><strong>8、删除长期未使用的索引</strong></p>
<p>定期删除一些长时间未使用过的索引是一个非常好的习惯。</p>
<p>关于索引这个话题打算就此打住，最后要说一句，索引并不总是最好的工具，只有当索引帮助提高查询速度带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，简单的全表扫描更高效。对于中到大型的表，索引就非常有效。对于超大型的表，建立和维护索引的代价随之增长，这时候其他技术也许更有效，比如分区表。最后的最后，explain后再提测是一种美德。</p>
<p><strong>优化COUNT()查询</strong></p>
<p>COUNT()可能是被大家误解最多的函数了，它有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时，要求列值是非空的，它不会统计NULL。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用COUNT(*)时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数。</p>
<p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用COUNT(*)，意义清晰，且性能更好。</p>
<p>有时候某些业务场景并不需要完全精确的COUNT值，可以用近似值来代替，EXPLAIN出来的行数就是一个不错的近似值，而且执行EXPLAIN并不需要真正地去执行查询，所以成本非常低。通常来说，执行COUNT()都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用redis这样的外部缓存系统。</p>
<p><strong>优化关联查询</strong></p>
<p>在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用JOIN有更好的性能。如果确实需要使用关联查询的情况下，需要特别注意的是：</p>
<ol>
<li>确保ON和USING字句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器关联的顺序是A、B，那么就不需要在A表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。</li>
<li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化。</li>
</ol>
<p>要理解优化关联查询的第一个技巧，就需要理解MySQL是如何执行关联查询的。当前MySQL关联执行的策略非常简单，它对任何的关联都执行<strong>嵌套循环关联操作</strong>，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p>
<p>太抽象了？以上面的示例来说明，比如有这样的一个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT A.xx,B.yy</span><br><span class="line"></span><br><span class="line">FROM A INNER JOIN B USING(c)</span><br><span class="line"></span><br><span class="line">WHERE A.xx IN (5,6)</span><br></pre></td></tr></table></figure>





<p>假设MySQL按照查询中的关联顺序A、B来进行关联操作，那么可以用下面的伪代码表示MySQL如何完成这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outer_iterator = SELECT A.xx,A.c FROM A WHERE A.xx IN (5,6);</span><br><span class="line"></span><br><span class="line">outer_row = outer_iterator.next;</span><br><span class="line"></span><br><span class="line">while(outer_row) &#123;</span><br><span class="line"></span><br><span class="line">  inner_iterator = SELECT B.yy FROM B WHERE B.c = outer_row.c;</span><br><span class="line"></span><br><span class="line">  inner_row = inner_iterator.next;</span><br><span class="line"></span><br><span class="line">  while(inner_row) &#123;</span><br><span class="line"></span><br><span class="line">	output[inner_row.yy,outer_row.xx];</span><br><span class="line"></span><br><span class="line">  inner_row = inner_iterator.next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  outer_row = outer_iterator.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>可以看到，最外层的查询是根据A.xx列来查询的，A.c上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显B.c上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</p>
<p><strong>优化LIMIT分页</strong></p>
<p>当需要分页操作时，通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY字句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。</p>
<p>一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高。</p>
<p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT film_id,description FROM film ORDER BY title LIMIT 50,5;</span><br></pre></td></tr></table></figure>

<p>如果这张表非常大，那么这个查询最好改成下面的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT film.film_id,film.description</span><br><span class="line"></span><br><span class="line">FROM film INNER JOIN (</span><br><span class="line"></span><br><span class="line">  SELECT film_id FROM film ORDER BY title LIMIT 50,5</span><br><span class="line"></span><br><span class="line">) AS tmp USING(film_id);</span><br></pre></td></tr></table></figure>



<p>这里的延迟关联将大大提升查询效率，让MySQL扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p>
<p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET，比如下面的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id FROM t LIMIT 10000, 10;</span><br></pre></td></tr></table></figure>



<p>改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id FROM t WHERE id &gt; 10000 LIMIT 10;</span><br></pre></td></tr></table></figure>



<p>其它优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p>
<p><strong>优化UNION</strong></p>
<p>MySQL处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。</p>
<p>除非确实需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用ALL关键字，MySQL总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>理解查询是如何执行以及时间都消耗在哪些地方，再加上一些优化过程的知识，可以帮助大家更好的理解MySQL，理解常见优化技巧背后的原理。希望本文中的原理、示例能够帮助大家更好的将理论和实践联系起来，更多的将理论知识运用到实践中。</p>
<p>最后，给大家留个思考题吧</p>
<ul>
<li>在执行<code>INSERT INTO film (film_id,description)VALUES (111,&#39;花木兰&#39;);</code>这样的insert语句，当使用InnoDB这样的存储引擎时，都会加什么锁？</li>
</ul>
<p>欢迎讨论。</p>
<hr>
<p>[^参考]: 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2013<br>[^参考]: Baron Scbwartz 等著；宁海元 周振兴等译；高性能MySQL（第三版）; 电子工业出版社， 2013<br>[^参考]: <a href="https://www.juejin.im/book/6844733769996304392/section">MySQL 是怎样运行的：从根儿上理解 MySQL</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式锁的正确实现方式（Java版）</title>
    <url>/posts/705011ee/</url>
    <content><![CDATA[<blockquote>
<p>本博客使用第三方开源组件Jedis实现Redis客户端，且只考虑Redis服务端单机部署的场景。</p>
</blockquote>
<blockquote>
<p><strong>原文出处</strong> ：<a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement">Redis分布式锁的正确实现方式（Java版）</a> </p>
</blockquote>
<span id="more"></span>

<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>分布式锁一般有三种实现方式：</p>
<ol>
<li> 数据库乐观锁；</li>
<li> 基于Redis的分布式锁；</li>
<li> 基于ZooKeeper的分布式锁。</li>
</ol>
<p>本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。</p>
<hr>
<h4 id="二、可靠性"><a href="#二、可靠性" class="headerlink" title="二、可靠性"></a>二、可靠性</h4><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ol>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
</ol>
<h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><h5 id="（一）组件依赖"><a href="#（一）组件依赖" class="headerlink" title="（一）组件依赖"></a>（一）组件依赖</h5><p>首先我们要通过Maven引入<code>Jedis</code>开源组件，在<code>pom.xml</code>文件加入下面的代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="（二）加锁代码"><a href="#（二）加锁代码" class="headerlink" title="（二）加锁代码"></a>（二）加锁代码</h5><h6 id="1、正确姿势"><a href="#1、正确姿势" class="headerlink" title="1、正确姿势"></a>1、正确姿势</h6><p>Talk is cheap, show me the code。先展示代码，再带大家慢慢解释为什么这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">&quot;NX&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">&quot;PX&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：</p>
<ul>
<li><p>第一个为key，我们使用key来当锁，因为key是唯一的。</p>
</li>
<li><p>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</p>
</li>
<li><p>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</p>
</li>
<li><p>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</p>
</li>
<li><p>第五个为time，与第四个参数相呼应，代表key的过期时间。</p>
</li>
</ul>
<p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p>
<p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p>
<h6 id="2、错误示例1"><a href="#2、错误示例1" class="headerlink" title="2、错误示例1"></a>2、错误示例1</h6><p>比较常见的错误示例就是使用<code>jedis.setnx()</code>和<code>jedis.expire()</code>组合实现加锁，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p>
<h6 id="3、错误示例2"><a href="#3、错误示例2" class="headerlink" title="3、错误示例2"></a>3、错误示例2</h6><p>这一种错误示例就比较难以发现问题，而且实现也比较复杂。实现思路：使用jedis.setnx()命令实现加锁，其中key是锁，value是锁的过期时间。执行过程：1. 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。2. 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">wrongGetLock2</span><span class="params">(Jedis jedis, String lockKey, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> expires = System.currentTimeMillis() + expireTime;</span><br><span class="line">    String expiresStr = String.valueOf(expires);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (jedis.setnx(lockKey, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果锁存在，获取锁的过期时间</span></span><br><span class="line">    String currentValueStr = jedis.get(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">        String oldValueStr = jedis.getSet(lockKey, expiresStr);</span><br><span class="line">        <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">            <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 其他情况，一律返回加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么这段代码问题在哪里？1. 由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步。 2. 当锁过期的时候，如果多个客户端同时执行jedis.getSet()方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁。</p>
<h5 id="（三）解锁代码"><a href="#（三）解锁代码" class="headerlink" title="（三）解锁代码"></a>（三）解锁代码</h5><h6 id="1、正确姿势-1"><a href="#1、正确姿势-1" class="headerlink" title="1、正确姿势"></a>1、正确姿势</h6><p>还是先展示代码，再带大家慢慢解释为什么这样实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p>
<p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读【解锁代码-错误示例2】 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：<br><img src="/uploads/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F_01.png" alt="Redis分布式锁的正确实现方式"></p>
<p>简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p>
<h6 id="2、错误示例1-1"><a href="#2、错误示例1-1" class="headerlink" title="2、错误示例1"></a>2、错误示例1</h6><p>最常见的解锁代码就是直接使用jedis.del()方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock1</span><span class="params">(Jedis jedis, String lockKey)</span> </span>&#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3、错误示例2-1"><a href="#3、错误示例2-1" class="headerlink" title="3、错误示例2"></a>3、错误示例2</h6><p>这种解锁代码乍一看也是没问题，甚至我之前也差点这样实现，与正确姿势差不多，唯一区别的是分成两条命令去执行，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongReleaseLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 判断加锁与解锁是不是同一个客户端</span></span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">        <span class="comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span></span><br><span class="line">        jedis.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码注释，问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p>
<hr>
<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>本文主要介绍了如何使用Java代码正确实现Redis分布式锁，对于加锁和解锁也分别给出了两个比较经典的错误示例。其实想要通过Redis实现分布式锁并不难，只要保证能满足可靠性里的四个条件。互联网虽然给我们带来了方便，只要有问题就可以google，然而网上的答案一定是对的吗？其实不然，所以我们更应该时刻保持着质疑精神，多想多验证。</p>
<p>如果你的项目中Redis是多机部署的，那么可以尝试使用Redisson实现分布式锁，这是Redis官方提供的Java组件，链接在参考阅读章节已经给出。</p>
<h4 id="五、参考阅读"><a href="#五、参考阅读" class="headerlink" title="五、参考阅读"></a>五、参考阅读</h4><ul>
<li><a href="https://redis.io/topics/distlock">Distributed locks with Redis</a></li>
<li><a href="https://redis.io/commands/eval">EVAL command</a></li>
<li><a href="https://github.com/redisson/redisson">Redisson</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>分布式锁</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle_local_and_remoting_repositories</title>
    <url>/posts/ce4646a7/</url>
    <content><![CDATA[<h3 id="1、本地仓库"><a href="#1、本地仓库" class="headerlink" title="1、本地仓库"></a>1、本地仓库</h3><p>配置环境变量<code>GRADLE_USER_HOME</code>，并指向你的一个本地目录，用来保存Gradle下载的依赖包。通常我们配置成和<code>Maven</code>同一个本地路径</p>
<p><img src="/uploads/img/gradle_local_resp.png" alt="gradle本地仓库"></p>
<span id="more"></span>

<h3 id="2、远程仓库"><a href="#2、远程仓库" class="headerlink" title="2、远程仓库"></a>2、远程仓库</h3><p>一般Gradle、maven从中央仓库<code>mavenCentral（）</code> <a href="http://repo1.maven.org/maven2/">http://repo1.maven.org/maven2/</a>下载依赖包，但是在国内下载速度巨慢，我们只能使用国内的镜像。<br>所以每个Gradle构建的项目中，我们可以在build.gradle做如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个项目都如此配置难免麻烦些，我们可以配置一个全局配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.gradle\init.gradle</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allprojects&#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        def REPOSITORY_URL = &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span><br><span class="line">        all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">            if(repo instanceof MavenArtifactRepository)&#123;</span><br><span class="line">                def url = repo.url.toString()</span><br><span class="line">                if (url.startsWith(&#x27;https://repo1.maven.org/maven2&#x27;) || url.startsWith(&#x27;https://jcenter.bintray.com/&#x27;)) &#123;</span><br><span class="line">                    project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $REPOSITORY_URL.&quot;</span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url REPOSITORY_URL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/img/20170712202941878.png" alt="gradle远程仓库"></p>
<h3 id="3、init-gradle简介"><a href="#3、init-gradle简介" class="headerlink" title="3、init.gradle简介"></a>3、init.gradle简介</h3><p>init.gradle文件在build开始之前执行，所以你可以在这个文件配置一些你想预先加载的操作<br>例如配置build日志输出、配置你的机器信息，比如jdk安装目录，配置在build时必须个人信息，比如仓库或者数据库的认证信息，and so on.</p>
<p>启用init.gradle文件的方法： </p>
<ol>
<li>在命令行指定文件，例如：gradle –init-script yourdir/init.gradle -q taskName.你可以多次输入此命令来指定多个init文件 </li>
<li>把init.gradle文件放到USER_HOME/.gradle/ 目录下. </li>
<li>把以.gradle结尾的文件放到USER_HOME/.gradle/init.d/ 目录下. </li>
<li>把以.gradle结尾的文件放到GRADLE_HOME/init.d/ 目录下.</li>
</ol>
<p>如果存在上面的4种方式的2种以上，gradle会按上面的1-4序号依次执行这些文件，如果给定目录下存在多个init脚本，会按拼音a-z顺序执行这些脚本<br>类似于build.gradle脚本，init脚本有时groovy语言脚本。每个init脚本都存在一个对应的gradle实例，你在这个文件中调用的所有方法和属性，都会<br>委托给这个gradle实例，每个init脚本都实现了Script接口</p>
<p>下面的例子是在build执行之前给所有的项目制定maven本地库，这个例子同时在 build.gradle文件指定了maven的仓库中心，注意它们之间异同</p>
<p>build.gradle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task showRepos &lt;&lt; &#123;</span><br><span class="line">    println &quot;All repos:&quot;</span><br><span class="line">    println repositories.collect &#123; it.name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init.gradle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行输入命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle –init-script init.gradle -q showRepos</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; gradle --init-script init.gradle -q showRepos</span><br><span class="line">All repos:</span><br><span class="line">[MavenLocal, MavenRepo]</span><br></pre></td></tr></table></figure>
<h3 id="4、参考"><a href="#4、参考" class="headerlink" title="4、参考"></a>4、参考</h3><p><a href="https://blog.csdn.net/x_iya/article/details/75040806">https://blog.csdn.net/x_iya/article/details/75040806</a></p>
]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>构建工具</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>design-patterns</title>
    <url>/posts/14da54c5/</url>
    <content><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。本章我们会以理论与实践相结合的方式来进行本章的学习，希望广大程序爱好者，学好设计模式，做一个优秀的软件工程师！</p>
<span id="more"></span>

<h2 id="一、设计模式的分类"><a href="#一、设计模式的分类" class="headerlink" title="一、设计模式的分类"></a>一、设计模式的分类</h2><p>总体来说设计模式分为三大类：</p>
<p>　　创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>　　结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>　　行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p>其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下：<br><img src="/uploads/img/design-patterns.jpg" alt="设计模式之间的关系"></p>
<h2 id="二、设计模式的六大原则"><a href="#二、设计模式的六大原则" class="headerlink" title="二、设计模式的六大原则"></a>二、设计模式的六大原则</h2><ul>
<li>开闭原则（Open Close Principle）</li>
</ul>
<p>　　开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<ul>
<li>里氏代换原则（Liskov Substitution Principle）</li>
</ul>
<p>　　里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<ul>
<li>依赖倒转原则（Dependence Inversion Principle）</li>
</ul>
<p>　　这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<ul>
<li>接口隔离原则（Interface Segregation Principle）</li>
</ul>
<p>　　这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<ul>
<li>迪米特法则（最少知道原则）（Demeter Principle）</li>
</ul>
<p>　　为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<ul>
<li>合成复用原则（Composite Reuse Principle）</li>
</ul>
<p>　　原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>design-pattern-singleton</title>
    <url>/posts/76432ff4/</url>
    <content><![CDATA[<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><ul>
<li>单例模式限制了一个类的实例化，并确保java虚拟机中只存在一个类的实例。</li>
<li>单例类必须提供一个全局访问点来获取类的实例。</li>
<li>单例模式用于日志记录，驱动程序对象，缓存和线程池。</li>
<li>Singleton设计模式也用于其他设计模式，如Abstract Factory，Builder，Prototype，Facade等。</li>
</ul>
<span id="more"></span>

<h3 id="2-要点"><a href="#2-要点" class="headerlink" title="2.要点"></a>2.要点</h3><ul>
<li>私有的构造函数</li>
<li>公共静态方法，返回类的实例，这是外部世界获取单例类的实例的全局访问点。</li>
</ul>
<h3 id="3-饿汉式单例"><a href="#3-饿汉式单例" class="headerlink" title="3.饿汉式单例"></a>3.饿汉式单例</h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hexsmith.design.pattern.creational.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:饿汉式单例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hexsmith</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月6日 下午6:36:41 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerInitializedSingleton</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerInitializedSingleton instance = <span class="keyword">new</span> EagerInitializedSingleton();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">EagerInitializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerInitializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>这种在初始化时，Singleton类的实例是在类加载时创建的，这是创建单例类的最简单的方法，但它有一个缺点即使客户端应用程序可能没有使用它也会创建实例。</p>
<h3 id="4-懒汉式单例"><a href="#4-懒汉式单例" class="headerlink" title="4.懒汉式单例"></a>4.懒汉式单例</h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hexsmith.design.pattern.creational.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:懒汉式单例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hexsmith</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月6日 下午6:47:10 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitializedSingleton</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LazyInitializedSingleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazyInitializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInitializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> LazyInitializedSingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>上面的实现对单线程环境工作良好，但是当涉及到多线程系统时，如果多个线程同时处于if循环内部，则会导致问题。它会破坏单例模式，两个线程都会得到单例类的不同实例。</p>
<h3 id="5-静态代码块实现单例"><a href="#5-静态代码块实现单例" class="headerlink" title="5.静态代码块实现单例"></a>5.静态代码块实现单例</h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hexsmith.design.pattern.creational.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:使用static代码块实现单例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hexsmith</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月6日 下午6:41:15 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBlockSingleton</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> StaticBlockSingleton instance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">StaticBlockSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> StaticBlockSingleton();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Exception occured in creating singleton instance&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticBlockSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="6-静态内部类实现单例"><a href="#6-静态内部类实现单例" class="headerlink" title="6.静态内部类实现单例"></a>6.静态内部类实现单例</h3><p>在Java 5之前，Java内存模型存在很多问题，以上方法在某些情况下失败，因为太多的线程试图同时获得Singleton类的实例。所以Bill Pugh提出了一种使用内部静态帮助类来创建Singleton类的另一种方法。Bill Pugh Singleton的实现是这样的<br>    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hexsmith.design.pattern.creational.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 静态内部类实现单例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hexsmith</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年5月9日 下午3:44:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillPughSingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BillPughSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">singletonHelper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BillPughSingleton instance = <span class="keyword">new</span> BillPughSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BillPughSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonHelper.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意包含单例类的实例的私有内部静态类。加载单例类时，SingletonHelper类不会加载到内存中，只有当有人调用getInstance方法时，才会加载此类，并创建Singleton类实例。这是Singleton类最广泛使用的方法，因为它不需要同步。</p>
<h3 id="7-线程安全的单例模式"><a href="#7-线程安全的单例模式" class="headerlink" title="7.线程安全的单例模式"></a>7.线程安全的单例模式</h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hexsmith.design.pattern.creational.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:线程安全的单例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hexsmith</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017年11月6日 下午6:50:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadSafeSingleton instance;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ThreadSafeSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> ThreadSafeSingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadSafeSingleton <span class="title">getInstanceUsingDoubleLocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (ThreadSafeSingleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> ThreadSafeSingleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>这种方式实现了线程安全的单例模式，但是在高并发场合使用时性能很糟糕。所以不推荐在高并发环境中使用</p>
<h3 id="8-单例模式序列化"><a href="#8-单例模式序列化" class="headerlink" title="8.单例模式序列化"></a>8.单例模式序列化</h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hexsmith.design.pattern.creational.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单例模式序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hexsmith</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年5月9日 下午4:16:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializedSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7308821136820448697L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SerializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerializedSingleton instance = <span class="keyword">new</span> SerializedSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SerializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="9-使用反射破坏单例模式"><a href="#9-使用反射破坏单例模式" class="headerlink" title="9.使用反射破坏单例模式"></a>9.使用反射破坏单例模式</h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hexsmith.design.pattern.creational.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 使用反射破坏单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hexsmith</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年5月9日 下午4:01:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionSingletonTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EagerInitializedSingleton instanceOne = EagerInitializedSingleton.getInstance();</span><br><span class="line">        EagerInitializedSingleton instanceTwo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor[] constructors = EagerInitializedSingleton.class.getDeclaredConstructors();</span><br><span class="line">            <span class="keyword">for</span>(Constructor constructor : constructors) &#123;</span><br><span class="line">                <span class="comment">// Below code will destroy the singleton pattern</span></span><br><span class="line">                constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                instanceTwo = (EagerInitializedSingleton)constructor.newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(instanceOne.hashCode());</span><br><span class="line">        System.out.println(instanceTwo.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="10-枚举单例"><a href="#10-枚举单例" class="headerlink" title="10.枚举单例"></a>10.枚举单例</h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hexsmith.design.pattern.creational.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 枚举方式的单例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hexsmith</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年5月9日 下午3:58:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>为了克服Reflection的这种情况，Joshua Bloch建议使用Enum来实现Singleton设计模式，因为Java确保任何枚举值在Java程序中仅实例化一次。由于Java Enum值是全局访问的，单例也是全局可访问的。缺点是枚举类型有点不灵活; 例如，它不允许延迟初始化</p>
<h3 id="11-参考资料"><a href="#11-参考资料" class="headerlink" title="11.参考资料"></a>11.参考资料</h3><ul>
<li><a href="https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples">https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>在IDE后台打印GC日志</title>
    <url>/posts/9ef48e76/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习JVM，阅读GC日志是处理Java虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有太多技术含量。</p>
<p>既然如此，那么在IDE的控制台打印GC日志是必不可少的了。现在就告诉你怎么打印。</p>
<span id="more"></span>

<h4 id="Eclipse配置打印GC日志"><a href="#Eclipse配置打印GC日志" class="headerlink" title="Eclipse配置打印GC日志"></a>Eclipse配置打印GC日志</h4><p><img src="http://images0.cnblogs.com/blog/641601/201508/171129239884226.png" alt="配置打印参数"></p>
<p><img src="http://images0.cnblogs.com/blog/641601/201508/171129257698181.png" alt="配置打印GC日志参数"></p>
<p>在上图的箭头处加上-XX:+PrintGCDetails这句话。于是，运行程序后，GC日志就可以打印出来了：</p>
<p><img src="/uploads/img/20180613222615.png" alt="控制台输出的GC日志"></p>
<h4 id="IntelliJ-IDEA-配置打印GC日志"><a href="#IntelliJ-IDEA-配置打印GC日志" class="headerlink" title="IntelliJ IDEA 配置打印GC日志"></a>IntelliJ IDEA 配置打印GC日志</h4><p><img src="http://images0.cnblogs.com/blog/641601/201508/171129297858722.png" alt="配置步骤"></p>
<p><img src="http://images0.cnblogs.com/blog/641601/201508/171129312389478.png" alt="配置VM参数"></p>
<p>在上图的箭头处加上-XX:+PrintGCDetails这句话。于是，运行程序后，GC日志就可以打印出来了：</p>
<p><img src="/uploads/img/20180613224136.png" alt="控制台输出GC日志"></p>
<p>当然了，光有<code>-XX:+PrintGCDetails</code>这一句参数肯定是不够的，下面我们详细介绍一下更多的参数配置。</p>
<h4 id="一、Trace跟踪参数："><a href="#一、Trace跟踪参数：" class="headerlink" title="一、Trace跟踪参数："></a>一、Trace跟踪参数：</h4><ol>
<li>打印GC的简要信息：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-verbose:gc</span><br><span class="line">-XX:+printGC</span><br></pre></td></tr></table></figure>
解释：可以打印GC的简要信息。比如：</li>
</ol>
<p>[GC 4790K-&gt;374K(15872K), 0.0001606 secs]</p>
<p>[GC 4790K-&gt;374K(15872K), 0.0001474 secs]</p>
<p>[GC 4790K-&gt;374K(15872K), 0.0001563 secs]</p>
<p>[GC 4790K-&gt;374K(15872K), 0.0001682 secs]</p>
<p>上方日志的意思是说，GC之前，用了4M左右的内存，GC之后，用了374K内存，一共回收了将近4M。内存大小一共是16M左右。<br>2. 打印GC的详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>
<p>解释：打印GC详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCTimeStamps</span><br></pre></td></tr></table></figure>
<p>解释：打印CG发生的时间戳。<br>理解GC日志的含义：</p>
<p>例如下面这段日志：</p>
<p>[GC[DefNew: 4416K-&gt;0K(4928K), 0.0001897 secs] 4790K-&gt;374K(15872K), 0.0002232 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </p>
<p>上方日志的意思是说：这是一个新生代的GC。方括号内部的“4416K-&gt;0K(4928K)”含义是：“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“4790K-&gt;374K(15872K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。</p>
<p>再往后看，“0.0001897 secs”表示该内存区域GC所占用的时间，单位是秒。</p>
<p>再比如下面这段GC日志：</p>
<p><img src="http://images0.cnblogs.com/blog/641601/201508/171129348949360.png" alt="enter description here"></p>
<p>上图中，我们先看一下用红框标注的“[0x27e80000, 0x28d80000, 0x28d80000)”的含义，它表示新生代在内存当中的位置：第一个参数是申请到的起始位置，第二个参数是申请到的终点位置，第三个参数表示最多能申请到的位置。上图中的例子表示新生代申请到了15M的控件，而这个15M是等于：（eden space的12288K）+（from space的1536K）+（to space的1536K）。</p>
<p>疑问：分配到的新生代有15M，但是可用的只有13824K，为什么会有这个差异呢？等我们在后面的文章中学习到了GC算法之后就明白了。</p>
<ol start="3">
<li>指定GC log的位置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xloggc:log/gc.log</span><br></pre></td></tr></table></figure>
解释：指定GC log的位置，以文件输出。帮助开发人员分析问题。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintHeapAtGC</span><br></pre></td></tr></table></figure>

<p>解释：每一次GC前和GC后，都打印堆信息。</p>
<p><img src="http://images0.cnblogs.com/blog/641601/201508/171129379106073.png" alt="堆栈信息"></p>
<p>上图中，红框部分正好是一次GC，红框部分的前面是GC之前的日志，红框部分的后面是GC之后的日志。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+TraceClassLoading</span><br></pre></td></tr></table></figure>

<p>解释：监控类的加载。</p>
<p>例如：</p>
<blockquote>
<p>[Loaded java.lang.Object from shared objects file]</p>
</blockquote>
<blockquote>
<p>[Loaded java.io.Serializable from shared objects file]</p>
</blockquote>
<blockquote>
<p>[Loaded java.lang.Comparable from shared objects file]</p>
</blockquote>
<blockquote>
<p>[Loaded java.lang.CharSequence from shared objects file]</p>
</blockquote>
<blockquote>
<p>[Loaded java.lang.String from shared objects file]</p>
</blockquote>
<blockquote>
<p>[Loaded java.lang.reflect.GenericDeclaration from shared objects file]</p>
</blockquote>
<blockquote>
<p>[Loaded java.lang.reflect.Type from shared objects file]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintClassHistogram</span><br></pre></td></tr></table></figure>
<p>解释：按下Ctrl+Break后，打印类的信息。</p>
<p>例如：</p>
<p><img src="http://images0.cnblogs.com/blog/641601/201508/171129389254130.png" alt="打印类信息"></p>
<h4 id="二、堆的分配参数："><a href="#二、堆的分配参数：" class="headerlink" title="二、堆的分配参数："></a>二、堆的分配参数：</h4><ol>
<li><p>-Xmx –Xms：指定最大堆和最小堆<br> 举例、当参数设置为如下时：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xmx20m -Xms5m</span><br></pre></td></tr></table></figure>
<p> 然后我们在程序中运行如下代码：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统的最大空间</span></span><br><span class="line">   System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// 系统的空闲空间</span></span><br><span class="line">   System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// 当前可用的总空间</span></span><br><span class="line">   System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br></pre></td></tr></table></figure>
<p> 运行效果：<br> <img src="/uploads/img/20180613230315.png" alt="打印堆信息"></p>
<p> 保持参数不变，在程序中运行如下代码：（分配1M空间给数组）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">&quot;分配了1M空间给数组&quot;</span>);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p> 运行效果：<br> <img src="/uploads/img/20180613231033.png" alt="enter description here"></p>
<p> 注：Java会尽可能将total mem的值维持在最小堆。</p>
<p> 保持参数不变，在程序中运行如下代码：（分配10M空间给数组）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] b = new byte[10 * 1024 * 1024];</span><br><span class="line">System.out.println(&quot;分配了10M空间给数组&quot;);</span><br></pre></td></tr></table></figure>
<p> 运行效果：<br> <img src="/uploads/img/20180613231333.png" alt="enter description here"></p>
<p> 保持参数不变，在程序中运行如下代码：（进行一次GC的回收）</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.gc();</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>eclipse</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>一个基础面试题</title>
    <url>/posts/43a1c559/</url>
    <content><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>2015 携程的 JAVA 工程师的面试题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String baseName = <span class="string">&quot;base&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		callName();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(baseName);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> String baseName = <span class="string">&quot;sub&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(baseName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Base base = <span class="keyword">new</span> Sub();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求这段程序的输出值？</p>
<span id="more"></span>

<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>因为本身一开始我也做错了这道题，因此不好写一开始的思考思路，我们就用最直接的方法来看下答案是什么？<br>其实，在自己编写这个程序的时候，我们可以把题目中的代码稍稍调整下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String baseName = <span class="string">&quot;base&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		callName();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(baseName);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> String baseName = <span class="string">&quot;sub&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		Sub()&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.baseName = <span class="string">&quot;sub&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		* 此处加一个<span class="doctag">@Override</span>注解，说明是对父类同名方法的重写</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(baseName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Base base = <span class="keyword">new</span> Sub();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接把程序运行，看输出的结果：<img src="/uploads/img/2136918-8173284a8ef38946.png" alt="直接运行输出结果"><br>可以看到，结果为 null 。为什么呢？</p>
<p>我们在仔细的观察一下题目，可以知道，这道题无非就是考察我们三个知识点，</p>
<ul>
<li>类的加载机制以及类的初始化过程；</li>
<li>继承的相关知识，其中这里涉及到子类继承父类的时候，同名的属性不会覆盖父类，只是会将父类的同名属性隐藏；</li>
<li>多态性，多态性就是让实现与接口进行分离，在这道题目中，在父类的构造方法中调用了虚函数造成多态</li>
</ul>
<p>既然我们上面就提到这个题目就是考察我们三个知识点，那么我们就根据题目对这三个知识点进行逐一击破</p>
<ol>
<li>类加载的机制和程序运行的顺序</li>
</ol>
<p>我们通过 Debug 能很好的了解程序的运行顺序，因为 new 了一个 Sub 对象，且 Sub 类中没有重写构造函数，因此会调用父类的构造函数，父类 Base 的构造函数中调用了 callName 方法，因此就在父类的 callName 方法中的输出语句打一个断点，最后因为子类的 Sub 重写了 callName 方法， 因此也在子类中重写的 callName 方法中打一个断点。最后通过 debug 我们可以看出程序的运行顺序<br><img src="/uploads/img/debug%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F.png" alt="debug查看运行的顺序"></p>
<p>知道了程序的运行顺序之后，我们还需知道一个知识点，那就是类的实例变量的初始化过程，也就是题目中成员变量 baseName 的初始化过程。</p>
<p>我们都知道，一个类一旦被加载连接初始化，它就可以随时被使用了，程序可以访问它的静态字段，调用静态方法，或者创建它的实例。在 JAVA 程序中类可以被明确或者隐含地实例化有四种途径：<br>(1) 明确使用 new 操作符；<br>(2) 调用 Class 或者 Constructor 对象的 newInstance() 方法；<br>(3) 调用任何现有对象的 clone() 方法；<br>(4) 通过 objectInputStream 类的 getObject() 方法反序列化。<br>虚拟机创建一个新的实例时，都需要在堆中为保存对象的实例分配内存。所有在对象的类中和它的父类中声明的变量（包括隐藏的实例变量）都要分配内存。一旦虚拟机为新的对象准备好堆内存，它立即把实例变量初始化为默认的初始值。</p>
<ol start="2">
<li>继承</li>
</ol>
<p>题目中 Sub 类继承了 Base 类，关于继承，一个基本所有人都知道的知识点，不过这里还是贴出来</p>
<blockquote>
<p>Java保证了一个对象被初始化前其父类也必须被初始化。有下面机制来保证：Java强制要求任何类的构造函数中的第一句必须是调用父类构造函数或者是类中定义的其他构造函数。如果没有构造函数，系统添加默认的无参构造函数，如果我们的构造函数中没有显示的调用父类的构造函数，那么编译器自动生成一个父类的无参构造函数</p>
</blockquote>
<ol start="3">
<li>多态</li>
</ol>
<p>父类中的构造函数调用了 callName 方法，在题目中是通过 new Sub() 对象，因此调用的是子类 Sub 类中的 callName 方法，因此当前的 this 是指 Sub 类中的。</p>
<p>好了，最后我们根据运行顺序分析整个过程<br>（1）Base b = new Sub();</p>
<p>在 main 方法中声明父类变量b对子类的引用，JAVA类加载器将Base,Sub类加载到JVM;也就是完成了 Base 类和 Sub 类的初始化</p>
<p>（2）JVM 为 Base,Sub 的的成员开辟内存空间且值均为 null</p>
<p>在初始化 Sub 对象前，首先 JAVA 虚拟机就在堆区开辟内存并将子类 Sub 中的 baseName 和父类 Base 中的 baseName（已被隐藏）均赋为 null ，至于为什么 Base 类中的 baseName 为什么会被隐藏，上面的知识点也已经说明，就是子类继承父类的时候，同名的属性不会覆盖父类，只是会将父类的同名属性隐藏</p>
<p>（3）调用父类的无参构造</p>
<p>调用 Sub 的构造函数，因为子类没有重写构造函数，默认调用无参的构造函数，调用了 super() 。</p>
<p>（4）callName 在子类中被重写，因此调用子类的 callName();</p>
<p>调用了父类的构造函数，父类的构造函数中调用了 callName 方法，此时父类中的 baseName 的值为 base，可是子类重写了 callName 方法，且 调用父类 Base 中的 callName 是在子类 Sub 中调用的，因此当前的 this 指向的是子类，也就是说是实现子类的 callName 方法</p>
<p>（5）调用子类的callName，打印baseName</p>
<p>实际上在new Sub()时，实际执行过程为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    baseName = <span class="string">&quot;sub&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，在 baseName = “sub” 执行前，子类的 callName() 已经执行，所以子类的 baseName 为默认值状态 null 。</p>
<h4 id="原文出处"><a href="#原文出处" class="headerlink" title="原文出处"></a>原文出处</h4><p>作者：fuck两点水<br>链接：<a href="https://www.jianshu.com/p/39f91f3fba32">https://www.jianshu.com/p/39f91f3fba32</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
